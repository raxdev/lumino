{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\r\n// Distributed under the terms of the Modified BSD License.\r\n/*-----------------------------------------------------------------------------\r\n| Copyright (c) 2014-2017, PhosphorJS Contributors\r\n|\r\n| Distributed under the terms of the BSD 3-Clause License.\r\n|\r\n| The full license is in the file LICENSE, distributed with this software.\r\n|----------------------------------------------------------------------------*/\r\nimport {\r\n  ArrayExt, each, find\r\n} from '@lumino/algorithm';\r\n\r\n\r\n\r\n/**\r\n * A type alias for a slot function.\r\n *\r\n * @param sender - The object emitting the signal.\r\n *\r\n * @param args - The args object emitted with the signal.\r\n *\r\n * #### Notes\r\n * A slot is invoked when a signal to which it is connected is emitted.\r\n */\r\nexport\r\ntype Slot<T, U> = (sender: T, args: U) => void;\r\n\r\n\r\n/**\r\n * An object used for type-safe inter-object communication.\r\n *\r\n * #### Notes\r\n * Signals provide a type-safe implementation of the publish-subscribe\r\n * pattern. An object (publisher) declares which signals it will emit,\r\n * and consumers connect callbacks (subscribers) to those signals. The\r\n * subscribers are invoked whenever the publisher emits the signal.\r\n */\r\nexport\r\ninterface ISignal<T, U> {\r\n  /**\r\n   * Connect a slot to the signal.\r\n   *\r\n   * @param slot - The slot to invoke when the signal is emitted.\r\n   *\r\n   * @param thisArg - The `this` context for the slot. If provided,\r\n   *   this must be a non-primitive object.\r\n   *\r\n   * @returns `true` if the connection succeeds, `false` otherwise.\r\n   *\r\n   * #### Notes\r\n   * Slots are invoked in the order in which they are connected.\r\n   *\r\n   * Signal connections are unique. If a connection already exists for\r\n   * the given `slot` and `thisArg`, this method returns `false`.\r\n   *\r\n   * A newly connected slot will not be invoked until the next time the\r\n   * signal is emitted, even if the slot is connected while the signal\r\n   * is dispatching.\r\n   */\r\n  connect(slot: Slot<T, U>, thisArg?: any): boolean;\r\n\r\n  /**\r\n   * Disconnect a slot from the signal.\r\n   *\r\n   * @param slot - The slot to disconnect from the signal.\r\n   *\r\n   * @param thisArg - The `this` context for the slot. If provided,\r\n   *   this must be a non-primitive object.\r\n   *\r\n   * @returns `true` if the connection is removed, `false` otherwise.\r\n   *\r\n   * #### Notes\r\n   * If no connection exists for the given `slot` and `thisArg`, this\r\n   * method returns `false`.\r\n   *\r\n   * A disconnected slot will no longer be invoked, even if the slot\r\n   * is disconnected while the signal is dispatching.\r\n   */\r\n  disconnect(slot: Slot<T, U>, thisArg?: any): boolean;\r\n}\r\n\r\n\r\n/**\r\n * A concrete implementation of `ISignal`.\r\n *\r\n * #### Example\r\n * ```typescript\r\n * import { ISignal, Signal } from '@lumino/signaling';\r\n *\r\n * class SomeClass {\r\n *\r\n *   constructor(name: string) {\r\n *     this.name = name;\r\n *   }\r\n *\r\n *   readonly name: string;\r\n *\r\n *   get valueChanged: ISignal<this, number> {\r\n *     return this._valueChanged;\r\n *   }\r\n *\r\n *   get value(): number {\r\n *     return this._value;\r\n *   }\r\n *\r\n *   set value(value: number) {\r\n *     if (value === this._value) {\r\n *       return;\r\n *     }\r\n *     this._value = value;\r\n *     this._valueChanged.emit(value);\r\n *   }\r\n *\r\n *   private _value = 0;\r\n *   private _valueChanged = new Signal<this, number>(this);\r\n * }\r\n *\r\n * function logger(sender: SomeClass, value: number): void {\r\n *   console.log(sender.name, value);\r\n * }\r\n *\r\n * let m1 = new SomeClass('foo');\r\n * let m2 = new SomeClass('bar');\r\n *\r\n * m1.valueChanged.connect(logger);\r\n * m2.valueChanged.connect(logger);\r\n *\r\n * m1.value = 42;  // logs: foo 42\r\n * m2.value = 17;  // logs: bar 17\r\n * ```\r\n */\r\nexport\r\nclass Signal<T, U> implements ISignal<T, U> {\r\n  /**\r\n   * Construct a new signal.\r\n   *\r\n   * @param sender - The sender which owns the signal.\r\n   */\r\n  constructor(sender: T) {\r\n    this.sender = sender;\r\n  }\r\n\r\n  /**\r\n   * The sender which owns the signal.\r\n   */\r\n  readonly sender: T;\r\n\r\n  /**\r\n   * Connect a slot to the signal.\r\n   *\r\n   * @param slot - The slot to invoke when the signal is emitted.\r\n   *\r\n   * @param thisArg - The `this` context for the slot. If provided,\r\n   *   this must be a non-primitive object.\r\n   *\r\n   * @returns `true` if the connection succeeds, `false` otherwise.\r\n   */\r\n  connect(slot: Slot<T, U>, thisArg?: any): boolean {\r\n    return Private.connect(this, slot, thisArg);\r\n  }\r\n\r\n  /**\r\n   * Disconnect a slot from the signal.\r\n   *\r\n   * @param slot - The slot to disconnect from the signal.\r\n   *\r\n   * @param thisArg - The `this` context for the slot. If provided,\r\n   *   this must be a non-primitive object.\r\n   *\r\n   * @returns `true` if the connection is removed, `false` otherwise.\r\n   */\r\n  disconnect(slot: Slot<T, U>, thisArg?: any): boolean {\r\n    return Private.disconnect(this, slot, thisArg);\r\n  }\r\n\r\n  /**\r\n   * Emit the signal and invoke the connected slots.\r\n   *\r\n   * @param args - The args to pass to the connected slots.\r\n   *\r\n   * #### Notes\r\n   * Slots are invoked synchronously in connection order.\r\n   *\r\n   * Exceptions thrown by connected slots will be caught and logged.\r\n   */\r\n  emit(args: U): void {\r\n    Private.emit(this, args);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * The namespace for the `Signal` class statics.\r\n */\r\nexport\r\nnamespace Signal {\r\n  /**\r\n   * Remove all connections between a sender and receiver.\r\n   *\r\n   * @param sender - The sender object of interest.\r\n   *\r\n   * @param receiver - The receiver object of interest.\r\n   *\r\n   * #### Notes\r\n   * If a `thisArg` is provided when connecting a signal, that object\r\n   * is considered the receiver. Otherwise, the `slot` is considered\r\n   * the receiver.\r\n   */\r\n  export\r\n  function disconnectBetween(sender: any, receiver: any): void {\r\n    Private.disconnectBetween(sender, receiver);\r\n  }\r\n\r\n  /**\r\n   * Remove all connections where the given object is the sender.\r\n   *\r\n   * @param sender - The sender object of interest.\r\n   */\r\n  export\r\n  function disconnectSender(sender: any): void {\r\n    Private.disconnectSender(sender);\r\n  }\r\n\r\n  /**\r\n   * Remove all connections where the given object is the receiver.\r\n   *\r\n   * @param receiver - The receiver object of interest.\r\n   *\r\n   * #### Notes\r\n   * If a `thisArg` is provided when connecting a signal, that object\r\n   * is considered the receiver. Otherwise, the `slot` is considered\r\n   * the receiver.\r\n   */\r\n  export\r\n  function disconnectReceiver(receiver: any): void {\r\n    Private.disconnectReceiver(receiver);\r\n  }\r\n\r\n  /**\r\n   * Remove all connections where an object is the sender or receiver.\r\n   *\r\n   * @param object - The object of interest.\r\n   *\r\n   * #### Notes\r\n   * If a `thisArg` is provided when connecting a signal, that object\r\n   * is considered the receiver. Otherwise, the `slot` is considered\r\n   * the receiver.\r\n   */\r\n  export\r\n  function disconnectAll(object: any): void {\r\n    Private.disconnectAll(object);\r\n  }\r\n\r\n  /**\r\n   * Clear all signal data associated with the given object.\r\n   *\r\n   * @param object - The object for which the data should be cleared.\r\n   *\r\n   * #### Notes\r\n   * This removes all signal connections and any other signal data\r\n   * associated with the object.\r\n   */\r\n  export\r\n  function clearData(object: any): void {\r\n    Private.disconnectAll(object);\r\n  }\r\n\r\n  /**\r\n   * A type alias for the exception handler function.\r\n   */\r\n  export\r\n  type ExceptionHandler = (err: Error) => void;\r\n\r\n  /**\r\n   * Get the signal exception handler.\r\n   *\r\n   * @returns The current exception handler.\r\n   *\r\n   * #### Notes\r\n   * The default exception handler is `console.error`.\r\n   */\r\n  export\r\n  function getExceptionHandler(): ExceptionHandler {\r\n    return Private.exceptionHandler;\r\n  }\r\n\r\n  /**\r\n   * Set the signal exception handler.\r\n   *\r\n   * @param handler - The function to use as the exception handler.\r\n   *\r\n   * @returns The old exception handler.\r\n   *\r\n   * #### Notes\r\n   * The exception handler is invoked when a slot throws an exception.\r\n   */\r\n  export\r\n  function setExceptionHandler(handler: ExceptionHandler): ExceptionHandler {\r\n    let old = Private.exceptionHandler;\r\n    Private.exceptionHandler = handler;\r\n    return old;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * The namespace for the module implementation details.\r\n */\r\nnamespace Private {\r\n  /**\r\n   * The signal exception handler function.\r\n   */\r\n  export\r\n  let exceptionHandler: Signal.ExceptionHandler = (err: Error) => {\r\n    console.error(err);\r\n  };\r\n\r\n  /**\r\n   * Connect a slot to a signal.\r\n   *\r\n   * @param signal - The signal of interest.\r\n   *\r\n   * @param slot - The slot to invoke when the signal is emitted.\r\n   *\r\n   * @param thisArg - The `this` context for the slot. If provided,\r\n   *   this must be a non-primitive object.\r\n   *\r\n   * @returns `true` if the connection succeeds, `false` otherwise.\r\n   */\r\n  export\r\n  function connect<T, U>(signal: Signal<T, U>, slot: Slot<T, U>, thisArg?: any): boolean {\r\n    // Coerce a `null` `thisArg` to `undefined`.\r\n    thisArg = thisArg || undefined;\r\n\r\n    // Ensure the sender's array of receivers is created.\r\n    let receivers = receiversForSender.get(signal.sender);\r\n    if (!receivers) {\r\n      receivers = [];\r\n      receiversForSender.set(signal.sender, receivers);\r\n    }\r\n\r\n    // Bail if a matching connection already exists.\r\n    if (findConnection(receivers, signal, slot, thisArg)) {\r\n      return false;\r\n    }\r\n\r\n    // Choose the best object for the receiver.\r\n    let receiver = thisArg || slot;\r\n\r\n    // Ensure the receiver's array of senders is created.\r\n    let senders = sendersForReceiver.get(receiver);\r\n    if (!senders) {\r\n      senders = [];\r\n      sendersForReceiver.set(receiver, senders);\r\n    }\r\n\r\n    // Create a new connection and add it to the end of each array.\r\n    let connection = { signal, slot, thisArg };\r\n    receivers.push(connection);\r\n    senders.push(connection);\r\n\r\n    // Indicate a successful connection.\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Disconnect a slot from a signal.\r\n   *\r\n   * @param signal - The signal of interest.\r\n   *\r\n   * @param slot - The slot to disconnect from the signal.\r\n   *\r\n   * @param thisArg - The `this` context for the slot. If provided,\r\n   *   this must be a non-primitive object.\r\n   *\r\n   * @returns `true` if the connection is removed, `false` otherwise.\r\n   */\r\n  export\r\n  function disconnect<T, U>(signal: Signal<T, U>, slot: Slot<T, U>, thisArg?: any): boolean {\r\n    // Coerce a `null` `thisArg` to `undefined`.\r\n    thisArg = thisArg || undefined;\r\n\r\n    // Lookup the list of receivers, and bail if none exist.\r\n    let receivers = receiversForSender.get(signal.sender);\r\n    if (!receivers || receivers.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    // Bail if no matching connection exits.\r\n    let connection = findConnection(receivers, signal, slot, thisArg);\r\n    if (!connection) {\r\n      return false;\r\n    }\r\n\r\n    // Choose the best object for the receiver.\r\n    let receiver = thisArg || slot;\r\n\r\n    // Lookup the array of senders, which is now known to exist.\r\n    let senders = sendersForReceiver.get(receiver)!;\r\n\r\n    // Clear the connection and schedule cleanup of the arrays.\r\n    connection.signal = null;\r\n    scheduleCleanup(receivers);\r\n    scheduleCleanup(senders);\r\n\r\n    // Indicate a successful disconnection.\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Remove all connections between a sender and receiver.\r\n   *\r\n   * @param sender - The sender object of interest.\r\n   *\r\n   * @param receiver - The receiver object of interest.\r\n   */\r\n  export\r\n  function disconnectBetween(sender: any, receiver: any): void {\r\n    // If there are no receivers, there is nothing to do.\r\n    let receivers = receiversForSender.get(sender);\r\n    if (!receivers || receivers.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // If there are no senders, there is nothing to do.\r\n    let senders = sendersForReceiver.get(receiver);\r\n    if (!senders || senders.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // Clear each connection between the sender and receiver.\r\n    each(senders, connection => {\r\n      // Skip connections which have already been cleared.\r\n      if (!connection.signal) {\r\n        return;\r\n      }\r\n\r\n      // Clear the connection if it matches the sender.\r\n      if (connection.signal.sender === sender) {\r\n        connection.signal = null;\r\n      }\r\n    });\r\n\r\n    // Schedule a cleanup of the senders and receivers.\r\n    scheduleCleanup(receivers);\r\n    scheduleCleanup(senders);\r\n  }\r\n\r\n  /**\r\n   * Remove all connections where the given object is the sender.\r\n   *\r\n   * @param sender - The sender object of interest.\r\n   */\r\n  export\r\n  function disconnectSender(sender: any): void {\r\n    // If there are no receivers, there is nothing to do.\r\n    let receivers = receiversForSender.get(sender);\r\n    if (!receivers || receivers.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // Clear each receiver connection.\r\n    each(receivers, connection => {\r\n      // Skip connections which have already been cleared.\r\n      if (!connection.signal) {\r\n        return;\r\n      }\r\n\r\n      // Choose the best object for the receiver.\r\n      let receiver = connection.thisArg || connection.slot;\r\n\r\n      // Clear the connection.\r\n      connection.signal = null;\r\n\r\n      // Cleanup the array of senders, which is now known to exist.\r\n      scheduleCleanup(sendersForReceiver.get(receiver)!);\r\n    });\r\n\r\n    // Schedule a cleanup of the receivers.\r\n    scheduleCleanup(receivers);\r\n  }\r\n\r\n  /**\r\n   * Remove all connections where the given object is the receiver.\r\n   *\r\n   * @param receiver - The receiver object of interest.\r\n   */\r\n  export\r\n  function disconnectReceiver(receiver: any): void {\r\n    // If there are no senders, there is nothing to do.\r\n    let senders = sendersForReceiver.get(receiver);\r\n    if (!senders || senders.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // Clear each sender connection.\r\n    each(senders, connection => {\r\n      // Skip connections which have already been cleared.\r\n      if (!connection.signal) {\r\n        return;\r\n      }\r\n\r\n      // Lookup the sender for the connection.\r\n      let sender = connection.signal.sender;\r\n\r\n      // Clear the connection.\r\n      connection.signal = null;\r\n\r\n      // Cleanup the array of receivers, which is now known to exist.\r\n      scheduleCleanup(receiversForSender.get(sender)!);\r\n    });\r\n\r\n    // Schedule a cleanup of the list of senders.\r\n    scheduleCleanup(senders);\r\n  }\r\n\r\n  /**\r\n   * Remove all connections where an object is the sender or receiver.\r\n   *\r\n   * @param object - The object of interest.\r\n   */\r\n  export\r\n  function disconnectAll(object: any): void {\r\n    // Remove all connections where the given object is the sender.\r\n    disconnectSender(object);\r\n    // Remove all connections where the given object is the receiver.\r\n    disconnectReceiver(object);\r\n  }\r\n\r\n  /**\r\n   * Emit a signal and invoke its connected slots.\r\n   *\r\n   * @param signal - The signal of interest.\r\n   *\r\n   * @param args - The args to pass to the connected slots.\r\n   *\r\n   * #### Notes\r\n   * Slots are invoked synchronously in connection order.\r\n   *\r\n   * Exceptions thrown by connected slots will be caught and logged.\r\n   */\r\n  export\r\n  function emit<T, U>(signal: Signal<T,  U>, args: U): void {\r\n    // If there are no receivers, there is nothing to do.\r\n    let receivers = receiversForSender.get(signal.sender);\r\n    if (!receivers || receivers.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // Invoke the slots for connections with a matching signal.\r\n    // Any connections added during emission are not invoked.\r\n    for (let i = 0, n = receivers.length; i < n; ++i) {\r\n      let connection = receivers[i];\r\n      if (connection.signal === signal) {\r\n        invokeSlot(connection, args);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * An object which holds connection data.\r\n   */\r\n  interface IConnection {\r\n    /**\r\n     * The signal for the connection.\r\n     *\r\n     * A `null` signal indicates a cleared connection.\r\n     */\r\n    signal: Signal<any, any> | null;\r\n\r\n    /**\r\n     * The slot connected to the signal.\r\n     */\r\n    readonly slot: Slot<any, any>;\r\n\r\n    /**\r\n     * The `this` context for the slot.\r\n     */\r\n    readonly thisArg: any;\r\n  }\r\n\r\n  /**\r\n   * A weak mapping of sender to array of receiver connections.\r\n   */\r\n  const receiversForSender = new WeakMap<any, IConnection[]>();\r\n\r\n  /**\r\n   * A weak mapping of receiver to array of sender connections.\r\n   */\r\n  const sendersForReceiver = new WeakMap<any, IConnection[]>();\r\n\r\n  /**\r\n   * A set of connection arrays which are pending cleanup.\r\n   */\r\n  const dirtySet = new Set<IConnection[]>();\r\n\r\n  /**\r\n   * A function to schedule an event loop callback.\r\n   */\r\n  const schedule = (() => {\r\n    let ok = typeof requestAnimationFrame === 'function';\r\n    // @ts-ignore\r\n    return ok ? requestAnimationFrame : setImmediate;\r\n  })();\r\n\r\n  /**\r\n   * Find a connection which matches the given parameters.\r\n   */\r\n  function findConnection(connections: IConnection[], signal: Signal<any, any>, slot: Slot<any, any>, thisArg: any): IConnection | undefined {\r\n    return find(connections, connection => (\r\n      connection.signal === signal &&\r\n      connection.slot === slot &&\r\n      connection.thisArg === thisArg\r\n    ));\r\n  }\r\n\r\n  /**\r\n   * Invoke a slot with the given parameters.\r\n   *\r\n   * The connection is assumed to be valid.\r\n   *\r\n   * Exceptions in the slot will be caught and logged.\r\n   */\r\n  function invokeSlot(connection: IConnection, args: any): void {\r\n    let { signal, slot, thisArg } = connection;\r\n    try {\r\n      slot.call(thisArg, signal!.sender, args);\r\n    } catch (err) {\r\n      exceptionHandler(err);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Schedule a cleanup of a connection array.\r\n   *\r\n   * This will add the array to the dirty set and schedule a deferred\r\n   * cleanup of the array contents. On cleanup, any connection with a\r\n   * `null` signal will be removed from the array.\r\n   */\r\n  function scheduleCleanup(array: IConnection[]): void {\r\n    if (dirtySet.size === 0) {\r\n      schedule(cleanupDirtySet);\r\n    }\r\n    dirtySet.add(array);\r\n  }\r\n\r\n  /**\r\n   * Cleanup the connection lists in the dirty set.\r\n   *\r\n   * This function should only be invoked asynchronously, when the\r\n   * stack frame is guaranteed to not be on the path of user code.\r\n   */\r\n  function cleanupDirtySet(): void {\r\n    dirtySet.forEach(cleanupConnections);\r\n    dirtySet.clear();\r\n  }\r\n\r\n  /**\r\n   * Cleanup the dirty connections in a connections array.\r\n   *\r\n   * This will remove any connection with a `null` signal.\r\n   *\r\n   * This function should only be invoked asynchronously, when the\r\n   * stack frame is guaranteed to not be on the path of user code.\r\n   */\r\n  function cleanupConnections(connections: IConnection[]): void {\r\n    ArrayExt.removeAllWhere(connections, isDeadConnection);\r\n  }\r\n\r\n  /**\r\n   * Test whether a connection is dead.\r\n   *\r\n   * A dead connection has a `null` signal.\r\n   */\r\n  function isDeadConnection(connection: IConnection): boolean {\r\n    return connection.signal === null;\r\n  }\r\n}\r\n"],"names":["Signal","each","find","ArrayExt"],"mappings":"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"}