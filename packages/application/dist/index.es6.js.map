{"version":3,"file":"index.es6.js","sources":["../../../node_modules/tslib/tslib.es6.js","../src/index.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","// Copyright (c) Jupyter Development Team.\r\n// Distributed under the terms of the Modified BSD License.\r\n/*-----------------------------------------------------------------------------\r\n| Copyright (c) 2014-2017, PhosphorJS Contributors\r\n|\r\n| Distributed under the terms of the BSD 3-Clause License.\r\n|\r\n| The full license is in the file LICENSE, distributed with this software.\r\n|----------------------------------------------------------------------------*/\r\nimport {\r\n  CommandRegistry\r\n} from '@lumino/commands';\r\n\r\nimport {\r\n  PromiseDelegate, Token\r\n} from '@lumino/coreutils';\r\n\r\nimport {\r\n  ContextMenu, Menu, Widget\r\n} from '@lumino/widgets';\r\n\r\n\r\n/**\r\n * A user-defined application plugin.\r\n *\r\n * #### Notes\r\n * Plugins are the foundation for building an extensible application.\r\n *\r\n * Plugins consume and provide \"services\", which are nothing more than\r\n * concrete implementations of interfaces and/or abstract types.\r\n *\r\n * Unlike regular imports and exports, which tie the service consumer\r\n * to a particular implementation of the service, plugins decouple the\r\n * service producer from the service consumer, allowing an application\r\n * to be easily customized by third parties in a type-safe fashion.\r\n */\r\nexport\r\ninterface IPlugin<T, U> {\r\n  /**\r\n   * The human readable id of the plugin.\r\n   *\r\n   * #### Notes\r\n   * This must be unique within an application.\r\n   */\r\n  id: string;\r\n\r\n  /**\r\n   * Whether the plugin should be activated on application start.\r\n   *\r\n   * #### Notes\r\n   * The default is `false`.\r\n   */\r\n  autoStart?: boolean;\r\n\r\n  /**\r\n   * The types of required services for the plugin, if any.\r\n   *\r\n   * #### Notes\r\n   * These tokens correspond to the services that are required by\r\n   * the plugin for correct operation.\r\n   *\r\n   * When the plugin is activated, a concrete instance of each type\r\n   * will be passed to the `activate()` function, in the order they\r\n   * are specified in the `requires` array.\r\n   */\r\n  requires?: Token<any>[];\r\n\r\n  /**\r\n   * The types of optional services for the plugin, if any.\r\n   *\r\n   * #### Notes\r\n   * These tokens correspond to the services that can be used by the\r\n   * plugin if available, but are not necessarily required.\r\n   *\r\n   * The optional services will be passed to the `activate()` function\r\n   * following all required services. If an optional service cannot be\r\n   * resolved, `null` will be passed in its place.\r\n   */\r\n  optional?: Token<any>[];\r\n\r\n  /**\r\n   * The type of service provided by the plugin, if any.\r\n   *\r\n   * #### Notes\r\n   * This token corresponds to the service exported by the plugin.\r\n   *\r\n   * When the plugin is activated, the return value of `activate()`\r\n   * is used as the concrete instance of the type.\r\n   */\r\n  provides?: Token<U>;\r\n\r\n  /**\r\n   * A function invoked to activate the plugin.\r\n   *\r\n   * @param app - The application which owns the plugin.\r\n   *\r\n   * @param args - The services specified by the `requires` property.\r\n   *\r\n   * @returns The provided service, or a promise to the service.\r\n   *\r\n   * #### Notes\r\n   * This function will be called whenever the plugin is manually\r\n   * activated, or when another plugin being activated requires\r\n   * the service it provides.\r\n   *\r\n   * This function will not be called unless all of its required\r\n   * services can be fulfilled.\r\n   */\r\n  activate: (app: T, ...args: any[]) => U | Promise<U>;\r\n}\r\n\r\n\r\n/**\r\n * A class for creating pluggable applications.\r\n *\r\n * #### Notes\r\n * The `Application` class is useful when creating large, complex\r\n * UI applications with the ability to be safely extended by third\r\n * party code via plugins.\r\n */\r\nexport\r\nclass Application<T extends Widget> {\r\n  /**\r\n   * Construct a new application.\r\n   *\r\n   * @param options - The options for creating the application.\r\n   */\r\n  constructor(options: Application.IOptions<T>) {\r\n    // Create the application command registry.\r\n    let commands = new CommandRegistry();\r\n\r\n    // Create the application context menu.\r\n    let renderer = options.contextMenuRenderer;\r\n    let contextMenu = new ContextMenu({ commands, renderer });\r\n\r\n    // Initialize the application state.\r\n    this.commands = commands;\r\n    this.contextMenu = contextMenu;\r\n    this.shell = options.shell;\r\n  }\r\n\r\n  /**\r\n   * The application command registry.\r\n   */\r\n  readonly commands: CommandRegistry;\r\n\r\n  /**\r\n   * The application context menu.\r\n   */\r\n  readonly contextMenu: ContextMenu;\r\n\r\n  /**\r\n   * The application shell widget.\r\n   *\r\n   * #### Notes\r\n   * The shell widget is the root \"container\" widget for the entire\r\n   * application. It will typically expose an API which allows the\r\n   * application plugins to insert content in a variety of places.\r\n   */\r\n  readonly shell: T;\r\n\r\n  /**\r\n   * A promise which resolves after the application has started.\r\n   *\r\n   * #### Notes\r\n   * This promise will resolve after the `start()` method is called,\r\n   * when all the bootstrapping and shell mounting work is complete.\r\n   */\r\n  get started(): Promise<void> {\r\n    return this._delegate.promise;\r\n  }\r\n\r\n  /**\r\n   * Test whether a plugin is registered with the application.\r\n   *\r\n   * @param id - The id of the plugin of interest.\r\n   *\r\n   * @returns `true` if the plugin is registered, `false` otherwise.\r\n   */\r\n  hasPlugin(id: string): boolean {\r\n    return id in this._pluginMap;\r\n  }\r\n\r\n  /**\r\n   * List the IDs of the plugins registered with the application.\r\n   *\r\n   * @returns A new array of the registered plugin IDs.\r\n   */\r\n  listPlugins(): string[] {\r\n    return Object.keys(this._pluginMap);\r\n  }\r\n\r\n  /**\r\n   * Register a plugin with the application.\r\n   *\r\n   * @param plugin - The plugin to register.\r\n   *\r\n   * #### Notes\r\n   * An error will be thrown if a plugin with the same id is already\r\n   * registered, or if the plugin has a circular dependency.\r\n   *\r\n   * If the plugin provides a service which has already been provided\r\n   * by another plugin, the new service will override the old service.\r\n   */\r\n  registerPlugin(plugin: IPlugin<this, any>): void {\r\n    // Throw an error if the plugin id is already registered.\r\n    if (plugin.id in this._pluginMap) {\r\n      throw new Error(`Plugin '${plugin.id}' is already registered.`);\r\n    }\r\n\r\n    // Create the normalized plugin data.\r\n    let data = Private.createPluginData(plugin);\r\n\r\n    // Ensure the plugin does not cause a cyclic dependency.\r\n    Private.ensureNoCycle(data, this._pluginMap, this._serviceMap);\r\n\r\n    // Add the service token to the service map.\r\n    if (data.provides) {\r\n      this._serviceMap.set(data.provides, data.id);\r\n    }\r\n\r\n    // Add the plugin to the plugin map.\r\n    this._pluginMap[data.id] = data;\r\n  }\r\n\r\n  /**\r\n   * Register multiple plugins with the application.\r\n   *\r\n   * @param plugins - The plugins to register.\r\n   *\r\n   * #### Notes\r\n   * This calls `registerPlugin()` for each of the given plugins.\r\n   */\r\n  registerPlugins(plugins: IPlugin<this, any>[]): void {\r\n    for (let plugin of plugins) {\r\n      this.registerPlugin(plugin);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Activate the plugin with the given id.\r\n   *\r\n   * @param id - The ID of the plugin of interest.\r\n   *\r\n   * @returns A promise which resolves when the plugin is activated\r\n   *   or rejects with an error if it cannot be activated.\r\n   */\r\n  activatePlugin(id: string): Promise<void> {\r\n    // Reject the promise if the plugin is not registered.\r\n    let data = this._pluginMap[id];\r\n    if (!data) {\r\n      return Promise.reject(new Error(`Plugin '${id}' is not registered.`));\r\n    }\r\n\r\n    // Resolve immediately if the plugin is already activated.\r\n    if (data.activated) {\r\n      return Promise.resolve(undefined);\r\n    }\r\n\r\n    // Return the pending resolver promise if it exists.\r\n    if (data.promise) {\r\n      return data.promise;\r\n    }\r\n\r\n    // Resolve the required services for the plugin.\r\n    let required = data.requires.map(t => this.resolveRequiredService(t));\r\n\r\n    // Resolve the optional services for the plugin.\r\n    let optional = data.optional.map(t => this.resolveOptionalService(t));\r\n\r\n    // Create the array of promises to resolve.\r\n    let promises = required.concat(optional);\r\n\r\n    // Setup the resolver promise for the plugin.\r\n    data.promise = Promise.all(promises).then(services => {\r\n      return data.activate.apply(undefined, [this, ...services]);\r\n    }).then(service => {\r\n      data.service = service;\r\n      data.activated = true;\r\n      data.promise = null;\r\n    }).catch(error => {\r\n      data.promise = null;\r\n      throw error;\r\n    });\r\n\r\n    // Return the pending resolver promise.\r\n    return data.promise;\r\n  }\r\n\r\n  /**\r\n   * Resolve a required service of a given type.\r\n   *\r\n   * @param token - The token for the service type of interest.\r\n   *\r\n   * @returns A promise which resolves to an instance of the requested\r\n   *   service, or rejects with an error if it cannot be resolved.\r\n   *\r\n   * #### Notes\r\n   * Services are singletons. The same instance will be returned each\r\n   * time a given service token is resolved.\r\n   *\r\n   * If the plugin which provides the service has not been activated,\r\n   * resolving the service will automatically activate the plugin.\r\n   *\r\n   * User code will not typically call this method directly. Instead,\r\n   * the required services for the user's plugins will be resolved\r\n   * automatically when the plugin is activated.\r\n   */\r\n  resolveRequiredService<U>(token: Token<U>): Promise<U> {\r\n    // Reject the promise if there is no provider for the type.\r\n    let id = this._serviceMap.get(token);\r\n    if (!id) {\r\n      return Promise.reject(new Error(`No provider for: ${token.name}.`));\r\n    }\r\n\r\n    // Resolve immediately if the plugin is already activated.\r\n    let data = this._pluginMap[id];\r\n    if (data.activated) {\r\n      return Promise.resolve(data.service);\r\n    }\r\n\r\n    // Otherwise, activate the plugin and wait on the results.\r\n    return this.activatePlugin(id).then(() => data.service);\r\n  }\r\n\r\n  /**\r\n   * Resolve an optional service of a given type.\r\n   *\r\n   * @param token - The token for the service type of interest.\r\n   *\r\n   * @returns A promise which resolves to an instance of the requested\r\n   *   service, or `null` if it cannot be resolved.\r\n   *\r\n   * #### Notes\r\n   * Services are singletons. The same instance will be returned each\r\n   * time a given service token is resolved.\r\n   *\r\n   * If the plugin which provides the service has not been activated,\r\n   * resolving the service will automatically activate the plugin.\r\n   *\r\n   * User code will not typically call this method directly. Instead,\r\n   * the optional services for the user's plugins will be resolved\r\n   * automatically when the plugin is activated.\r\n   */\r\n  resolveOptionalService<U>(token: Token<U>): Promise<U | null> {\r\n    // Resolve with `null` if there is no provider for the type.\r\n    let id = this._serviceMap.get(token);\r\n    if (!id) {\r\n      return Promise.resolve(null);\r\n    }\r\n\r\n    // Resolve immediately if the plugin is already activated.\r\n    let data = this._pluginMap[id];\r\n    if (data.activated) {\r\n      return Promise.resolve(data.service);\r\n    }\r\n\r\n    // Otherwise, activate the plugin and wait on the results.\r\n    return this.activatePlugin(id).then(() => {\r\n      return data.service;\r\n    }).catch(reason => {\r\n      console.error(reason);\r\n      return null;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Start the application.\r\n   *\r\n   * @param options - The options for starting the application.\r\n   *\r\n   * @returns A promise which resolves when all bootstrapping work\r\n   *   is complete and the shell is mounted to the DOM.\r\n   *\r\n   * #### Notes\r\n   * This should be called once by the application creator after all\r\n   * initial plugins have been registered.\r\n   *\r\n   * If a plugin fails to the load, the error will be logged and the\r\n   * other valid plugins will continue to be loaded.\r\n   *\r\n   * Bootstrapping the application consists of the following steps:\r\n   * 1. Activate the startup plugins\r\n   * 2. Wait for those plugins to activate\r\n   * 3. Attach the shell widget to the DOM\r\n   * 4. Add the application event listeners\r\n   */\r\n  start(options: Application.IStartOptions = {}): Promise<void> {\r\n    // Return immediately if the application is already started.\r\n    if (this._started) {\r\n      return this._delegate.promise;\r\n    }\r\n\r\n    // Mark the application as started;\r\n    this._started = true;\r\n\r\n    // Parse the host id for attaching the shell.\r\n    let hostID = options.hostID || '';\r\n\r\n    // Collect the ids of the startup plugins.\r\n    let startups = Private.collectStartupPlugins(this._pluginMap, options);\r\n\r\n    // Generate the activation promises.\r\n    let promises = startups.map(id => {\r\n      return this.activatePlugin(id).catch(error => {\r\n        console.error(`Plugin '${id}' failed to activate.`);\r\n        console.error(error);\r\n      });\r\n    });\r\n\r\n    // Wait for the plugins to activate, then finalize startup.\r\n    Promise.all(promises).then(() => {\r\n      this.attachShell(hostID);\r\n      this.addEventListeners();\r\n      this._delegate.resolve(undefined);\r\n    });\r\n\r\n    // Return the pending delegate promise.\r\n    return this._delegate.promise;\r\n  }\r\n\r\n  /**\r\n   * Handle the DOM events for the application.\r\n   *\r\n   * @param event - The DOM event sent to the application.\r\n   *\r\n   * #### Notes\r\n   * This method implements the DOM `EventListener` interface and is\r\n   * called in response to events registered for the application. It\r\n   * should not be called directly by user code.\r\n   */\r\n  handleEvent(event: Event): void {\r\n    switch (event.type) {\r\n    case 'resize':\r\n      this.evtResize(event);\r\n      break;\r\n    case 'keydown':\r\n      this.evtKeydown(event as KeyboardEvent);\r\n      break;\r\n    case 'contextmenu':\r\n      this.evtContextMenu(event as MouseEvent);\r\n      break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attach the application shell to the DOM.\r\n   *\r\n   * @param id - The id of the host node for the shell, or `''`.\r\n   *\r\n   * #### Notes\r\n   * If the id is not provided, the document body will be the host.\r\n   *\r\n   * A subclass may reimplement this method as needed.\r\n   */\r\n  protected attachShell(id: string): void {\r\n    Widget.attach(this.shell, (id && document.getElementById(id)) || document.body);\r\n  }\r\n\r\n  /**\r\n   * Add the application event listeners.\r\n   *\r\n   * #### Notes\r\n   * The default implementation of this method adds listeners for\r\n   * `'keydown'` and `'resize'` events.\r\n   *\r\n   * A subclass may reimplement this method as needed.\r\n   */\r\n  protected addEventListeners(): void {\r\n    document.addEventListener('contextmenu', this);\r\n    document.addEventListener('keydown', this, true);\r\n    window.addEventListener('resize', this);\r\n  }\r\n\r\n  /**\r\n   * A method invoked on a document `'keydown'` event.\r\n   *\r\n   * #### Notes\r\n   * The default implementation of this method invokes the key down\r\n   * processing method of the application command registry.\r\n   *\r\n   * A subclass may reimplement this method as needed.\r\n   */\r\n  protected evtKeydown(event: KeyboardEvent): void {\r\n    this.commands.processKeydownEvent(event);\r\n  }\r\n\r\n  /**\r\n   * A method invoked on a document `'contextmenu'` event.\r\n   *\r\n   * #### Notes\r\n   * The default implementation of this method opens the application\r\n   * `contextMenu` at the current mouse position.\r\n   *\r\n   * If the application context menu has no matching content *or* if\r\n   * the shift key is pressed, the default browser context menu will\r\n   * be opened instead.\r\n   *\r\n   * A subclass may reimplement this method as needed.\r\n   */\r\n  protected evtContextMenu(event: MouseEvent): void {\r\n    if (event.shiftKey) {\r\n      return;\r\n    }\r\n    if (this.contextMenu.open(event)) {\r\n      event.preventDefault();\r\n      event.stopPropagation();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * A method invoked on a window `'resize'` event.\r\n   *\r\n   * #### Notes\r\n   * The default implementation of this method updates the shell.\r\n   *\r\n   * A subclass may reimplement this method as needed.\r\n   */\r\n  protected evtResize(event: Event): void {\r\n    this.shell.update();\r\n  }\r\n\r\n  private _started = false;\r\n  private _pluginMap = Private.createPluginMap();\r\n  private _serviceMap = Private.createServiceMap();\r\n  private _delegate = new PromiseDelegate<void>();\r\n}\r\n\r\n\r\n/**\r\n * The namespace for the `Application` class statics.\r\n */\r\nexport\r\nnamespace Application {\r\n  /**\r\n   * An options object for creating an application.\r\n   */\r\n  export\r\n  interface IOptions<T extends Widget> {\r\n    /**\r\n     * The shell widget to use for the application.\r\n     *\r\n     * This should be a newly created and initialized widget.\r\n     *\r\n     * The application will attach the widget to the DOM.\r\n     */\r\n    shell: T;\r\n\r\n    /**\r\n     * A custom renderer for the context menu.\r\n     */\r\n    contextMenuRenderer?: Menu.IRenderer;\r\n  }\r\n\r\n  /**\r\n   * An options object for application startup.\r\n   */\r\n  export\r\n  interface IStartOptions {\r\n    /**\r\n     * The ID of the DOM node to host the application shell.\r\n     *\r\n     * #### Notes\r\n     * If this is not provided, the document body will be the host.\r\n     */\r\n    hostID?: string;\r\n\r\n    /**\r\n     * The plugins to activate on startup.\r\n     *\r\n     * #### Notes\r\n     * These will be *in addition* to any `autoStart` plugins.\r\n     */\r\n    startPlugins?: string[];\r\n\r\n    /**\r\n     * The plugins to **not** activate on startup.\r\n     *\r\n     * #### Notes\r\n     * This will override `startPlugins` and any `autoStart` plugins.\r\n     */\r\n    ignorePlugins?: string[];\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * The namespace for the module implementation details.\r\n */\r\nnamespace Private {\r\n  /**\r\n   * An object which holds the full application state for a plugin.\r\n   */\r\n  export\r\n  interface IPluginData {\r\n    /**\r\n     * The human readable id of the plugin.\r\n     */\r\n    readonly id: string;\r\n\r\n    /**\r\n     * Whether the plugin should be activated on application start.\r\n     */\r\n    readonly autoStart: boolean;\r\n\r\n    /**\r\n     * The types of required services for the plugin, or `[]`.\r\n     */\r\n    readonly requires: Token<any>[];\r\n\r\n    /**\r\n     * The types of optional services for the the plugin, or `[]`.\r\n     */\r\n    readonly optional: Token<any>[];\r\n\r\n    /**\r\n     * The type of service provided by the plugin, or `null`.\r\n     */\r\n    readonly provides: Token<any> | null;\r\n\r\n    /**\r\n     * The function which activates the plugin.\r\n     */\r\n    readonly activate: (app: any, ...args: any[]) => any;\r\n\r\n    /**\r\n     * Whether the plugin has been activated.\r\n     */\r\n    activated: boolean;\r\n\r\n    /**\r\n     * The resolved service for the plugin, or `null`.\r\n     */\r\n    service: any | null;\r\n\r\n    /**\r\n     * The pending resolver promise, or `null`.\r\n     */\r\n    promise: Promise<void> | null;\r\n  }\r\n\r\n  /**\r\n   * A type alias for a mapping of plugin id to plugin data.\r\n   */\r\n  export\r\n  type PluginMap = { [id: string]: IPluginData };\r\n\r\n  /**\r\n   * A type alias for a mapping of service token to plugin id.\r\n   */\r\n  export\r\n  type ServiceMap = Map<Token<any>, string>;\r\n\r\n  /**\r\n   * Create a new plugin map.\r\n   */\r\n  export\r\n  function createPluginMap(): PluginMap {\r\n    return Object.create(null);\r\n  }\r\n\r\n  /**\r\n   * Create a new service map.\r\n   */\r\n  export\r\n  function createServiceMap(): ServiceMap {\r\n    return new Map<Token<any>, string>();\r\n  }\r\n\r\n  /**\r\n   * Create a normalized plugin data object for the given plugin.\r\n   */\r\n  export\r\n  function createPluginData(plugin: IPlugin<any, any>): IPluginData {\r\n    return {\r\n      id: plugin.id,\r\n      service: null,\r\n      promise: null,\r\n      activated: false,\r\n      activate: plugin.activate,\r\n      provides: plugin.provides || null,\r\n      autoStart: plugin.autoStart || false,\r\n      requires: plugin.requires ? plugin.requires.slice() : [],\r\n      optional: plugin.optional ? plugin.optional.slice() : []\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Ensure no cycle is present in the plugin resolution graph.\r\n   *\r\n   * If a cycle is detected, an error will be thrown.\r\n   */\r\n  export\r\n  function ensureNoCycle(data: IPluginData, pluginMap: PluginMap, serviceMap: ServiceMap): void {\r\n    let dependencies = data.requires.concat(data.optional);\r\n    // Bail early if there cannot be a cycle.\r\n    if (!data.provides || dependencies.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // Setup a stack to trace service resolution.\r\n    let trace = [data.id];\r\n\r\n    // Throw an exception if a cycle is present.\r\n    if (dependencies.some(visit)) {\r\n      throw new Error(`Cycle detected: ${trace.join(' -> ')}.`);\r\n    }\r\n\r\n    function visit(token: Token<any>): boolean {\r\n      if (token === data.provides) {\r\n        return true;\r\n      }\r\n      let id = serviceMap.get(token);\r\n      if (!id) {\r\n        return false;\r\n      }\r\n      let other = pluginMap[id];\r\n      let otherDependencies = other.requires.concat(other.optional);\r\n      if (otherDependencies.length === 0) {\r\n        return false;\r\n      }\r\n      trace.push(id);\r\n      if (otherDependencies.some(visit)) {\r\n        return true;\r\n      }\r\n      trace.pop();\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Collect the IDs of the plugins to activate on startup.\r\n   */\r\n  export\r\n  function collectStartupPlugins(pluginMap: PluginMap, options: Application.IStartOptions): string[] {\r\n    // Create a map to hold the plugin IDs.\r\n    let resultMap: { [id: string]: boolean } = Object.create(null);\r\n\r\n    // Collect the auto-start plugins.\r\n    for (let id in pluginMap) {\r\n      if (pluginMap[id].autoStart) {\r\n        resultMap[id] = true;\r\n      }\r\n    }\r\n\r\n    // Add the startup plugins.\r\n    if (options.startPlugins) {\r\n      for (let id of options.startPlugins) {\r\n        resultMap[id] = true;\r\n      }\r\n    }\r\n\r\n    // Remove the ignored plugins.\r\n    if (options.ignorePlugins) {\r\n      for (let id of options.ignorePlugins) {\r\n        delete resultMap[id];\r\n      }\r\n    }\r\n\r\n    // Return the final startup plugins.\r\n    return Object.keys(resultMap);\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}